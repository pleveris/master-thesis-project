# -*- coding: utf-8 -*-
"""Fuzzy Control Systems.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x76Cezf26UrJ-_dtqU4mTR6NgsL0gBCQ
"""

#pip install -U -q scikit-fuzzy

"""# ðŸš¦ Traffic Light Control System Simulation"""

import numpy as np
import skfuzzy as fuzz
from skfuzzy import control as ctrl

# Define fuzzy variables
traffic_density_main = ctrl.Antecedent(np.arange(0, 11, 1), 'traffic_density_main')
traffic_density_side = ctrl.Antecedent(np.arange(0, 11, 1), 'traffic_density_side')
green_light_main = ctrl.Consequent(np.arange(0, 101, 1), 'green_light_main')

# Define membership functions
traffic_density_main['low'] = fuzz.trimf(traffic_density_main.universe, [0, 0, 5])
traffic_density_main['medium'] = fuzz.trimf(traffic_density_main.universe, [0, 5, 10])
traffic_density_main['high'] = fuzz.trimf(traffic_density_main.universe, [5, 10, 10])

traffic_density_side['low'] = fuzz.trimf(traffic_density_side.universe, [0, 0, 5])
traffic_density_side['medium'] = fuzz.trimf(traffic_density_side.universe, [0, 5, 10])
traffic_density_side['high'] = fuzz.trimf(traffic_density_side.universe, [5, 10, 10])

green_light_main['short'] = fuzz.trimf(green_light_main.universe, [0, 0, 50])
green_light_main['medium'] = fuzz.trimf(green_light_main.universe, [0, 50, 100])
green_light_main['long'] = fuzz.trimf(green_light_main.universe, [50, 100, 100])

# Define rules
rule1 = ctrl.Rule(traffic_density_main['low'] & traffic_density_side['low'], green_light_main['long'])
rule2 = ctrl.Rule(traffic_density_main['medium'] & traffic_density_side['low'], green_light_main['medium'])
rule3 = ctrl.Rule(traffic_density_main['high'] & traffic_density_side['low'], green_light_main['short'])
rule4 = ctrl.Rule(traffic_density_main['low'] & traffic_density_side['medium'], green_light_main['medium'])
rule5 = ctrl.Rule(traffic_density_main['medium'] & traffic_density_side['medium'], green_light_main['short'])
rule6 = ctrl.Rule(traffic_density_main['high'] & traffic_density_side['medium'], green_light_main['short'])
rule7 = ctrl.Rule(traffic_density_main['low'] & traffic_density_side['high'], green_light_main['short'])
rule8 = ctrl.Rule(traffic_density_main['medium'] & traffic_density_side['high'], green_light_main['short'])
rule9 = ctrl.Rule(traffic_density_main['high'] & traffic_density_side['high'], green_light_main['short'])

# Create control system
traffic_control = ctrl.ControlSystem([rule1, rule2, rule3, rule4, rule5, rule6, rule7, rule8, rule9])
traffic_control_simulation = ctrl.ControlSystemSimulation(traffic_control)

# Main loop for user input and output
while True:
    print("\nTraffic Light Control System Simulation")
    print("1. Simulate Traffic Light Control")
    print("2. Exit")

    choice = input("Enter your choice (1 or 2): ")

    if choice == '1':
        # User input for traffic density on main road
        traffic_density_main_input = float(input("Enter traffic density on the main road (0-10): "))
        while traffic_density_main_input < 0 or traffic_density_main_input > 10:
            print("Invalid input! Traffic density should be between 0 and 10.")
            traffic_density_main_input = float(input("Enter traffic density on the main road (0-10): "))

        # User input for traffic density on side road
        traffic_density_side_input = float(input("Enter traffic density on the side road (0-10): "))
        while traffic_density_side_input < 0 or traffic_density_side_input > 10:
            print("Invalid input! Traffic density should be between 0 and 10.")
            traffic_density_side_input = float(input("Enter traffic density on the side road (0-10): "))

        # Set input values
        traffic_control_simulation.input['traffic_density_main'] = traffic_density_main_input
        traffic_control_simulation.input['traffic_density_side'] = traffic_density_side_input

        # Compute the result
        traffic_control_simulation.compute()

        # Output result
        print("\nSimulation Results:")
        print("Green Light Duration on Main Road:", traffic_control_simulation.output['green_light_main'])
        print("Traffic Density on Main Road:", traffic_density_main_input)
        print("Traffic Density on Side Road:", traffic_density_side_input)

        # Display fuzzy logic matrices in tabular form
        print("\nFuzzy Logic Matrix for Traffic Density on Main Road:")
        print("Traffic Density\tLow\tMedium\tHigh")
        for val in range(11):
            print(f"{val}\t\t{fuzz.interp_membership(traffic_density_main.universe, traffic_density_main['low'].mf, val):.2f}\t{fuzz.interp_membership(traffic_density_main.universe, traffic_density_main['medium'].mf, val):.2f}\t{fuzz.interp_membership(traffic_density_main.universe, traffic_density_main['high'].mf, val):.2f}")

        print("\nFuzzy Logic Matrix for Traffic Density on Side Road:")
        print("Traffic Density\tLow\tMedium\tHigh")
        for val in range(11):
            print(f"{val}\t\t{fuzz.interp_membership(traffic_density_side.universe, traffic_density_side['low'].mf, val):.2f}\t{fuzz.interp_membership(traffic_density_side.universe, traffic_density_side['medium'].mf, val):.2f}\t{fuzz.interp_membership(traffic_density_side.universe, traffic_density_side['high'].mf, val):.2f}")

        print("\nFuzzy Logic Matrix for Green Light Duration on Main Road:")
        print("Green Light Duration\tShort\tMedium\tLong")
        for val in range(101):
            print(f"{val}\t\t{fuzz.interp_membership(green_light_main.universe, green_light_main['short'].mf, val):.2f}\t{fuzz.interp_membership(green_light_main.universe, green_light_main['medium'].mf, val):.2f}\t{fuzz.interp_membership(green_light_main.universe, green_light_main['long'].mf, val):.2f}")

        # Display output graphs
        traffic_density_main.view(sim=traffic_control_simulation)
        traffic_density_side.view(sim=traffic_control_simulation)
        green_light_main.view(sim=traffic_control_simulation)

    elif choice == '2':
        print("Exiting the program.")
        break

    else:
        print("Invalid choice! Please enter 1 or 2.")

"""# ðŸ¤‘ The Tipping Problem - The Hard Way

https://pythonhosted.org/scikit-fuzzy/auto_examples/plot_tipping_problem.html
"""

import numpy as np
import skfuzzy as fuzz
import matplotlib.pyplot as plt

# Generate universe variables
#   * Quality and service on subjective ranges [0, 10]
#   * Tip has a range of [0, 25] in units of percentage points
x_qual = np.arange(0, 11, 1)
x_serv = np.arange(0, 11, 1)
x_tip  = np.arange(0, 26, 1)

# Generate fuzzy membership functions
qual_lo = fuzz.trimf(x_qual, [0, 0, 5])
qual_md = fuzz.trimf(x_qual, [0, 5, 10])
qual_hi = fuzz.trimf(x_qual, [5, 10, 10])
serv_lo = fuzz.trimf(x_serv, [0, 0, 5])
serv_md = fuzz.trimf(x_serv, [0, 5, 10])
serv_hi = fuzz.trimf(x_serv, [5, 10, 10])
tip_lo = fuzz.trimf(x_tip, [0, 0, 13])
tip_md = fuzz.trimf(x_tip, [0, 13, 25])
tip_hi = fuzz.trimf(x_tip, [13, 25, 25])

# Visualize these universes and membership functions
fig, (ax0, ax1, ax2) = plt.subplots(nrows=3, figsize=(8, 9))

ax0.plot(x_qual, qual_lo, 'b', linewidth=1.5, label='Bad')
ax0.plot(x_qual, qual_md, 'g', linewidth=1.5, label='Decent')
ax0.plot(x_qual, qual_hi, 'r', linewidth=1.5, label='Great')
ax0.set_title('Food quality')
ax0.legend()

ax1.plot(x_serv, serv_lo, 'b', linewidth=1.5, label='Poor')
ax1.plot(x_serv, serv_md, 'g', linewidth=1.5, label='Acceptable')
ax1.plot(x_serv, serv_hi, 'r', linewidth=1.5, label='Amazing')
ax1.set_title('Service quality')
ax1.legend()

ax2.plot(x_tip, tip_lo, 'b', linewidth=1.5, label='Low')
ax2.plot(x_tip, tip_md, 'g', linewidth=1.5, label='Medium')
ax2.plot(x_tip, tip_hi, 'r', linewidth=1.5, label='High')
ax2.set_title('Tip amount')
ax2.legend()

# Turn off top/right axes
for ax in (ax0, ax1, ax2):
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.get_xaxis().tick_bottom()
    ax.get_yaxis().tick_left()

plt.tight_layout()

# We need the activation of our fuzzy membership functions at these values.
# The exact values 6.5 and 9.8 do not exist on our universes...
# This is what fuzz.interp_membership exists for!
qual_level_lo = fuzz.interp_membership(x_qual, qual_lo, 6.5)
qual_level_md = fuzz.interp_membership(x_qual, qual_md, 6.5)
qual_level_hi = fuzz.interp_membership(x_qual, qual_hi, 6.5)

serv_level_lo = fuzz.interp_membership(x_serv, serv_lo, 9.8)
serv_level_md = fuzz.interp_membership(x_serv, serv_md, 9.8)
serv_level_hi = fuzz.interp_membership(x_serv, serv_hi, 9.8)

# Now we take our rules and apply them. Rule 1 concerns bad food OR service.
# The OR operator means we take the maximum of these two.
active_rule1 = np.fmax(qual_level_lo, serv_level_lo)

# Now we apply this by clipping the top off the corresponding output
# membership function with `np.fmin`
tip_activation_lo = np.fmin(active_rule1, tip_lo)  # removed entirely to 0

# For rule 2 we connect acceptable service to medium tipping
tip_activation_md = np.fmin(serv_level_md, tip_md)

# For rule 3 we connect high service OR high food with high tipping
active_rule3 = np.fmax(qual_level_hi, serv_level_hi)
tip_activation_hi = np.fmin(active_rule3, tip_hi)
tip0 = np.zeros_like(x_tip)

# Visualize this
fig, ax0 = plt.subplots(figsize=(8, 3))

ax0.fill_between(x_tip, tip0, tip_activation_lo, facecolor='b', alpha=0.7)
ax0.plot(x_tip, tip_lo, 'b', linewidth=0.5, linestyle='--', )
ax0.fill_between(x_tip, tip0, tip_activation_md, facecolor='g', alpha=0.7)
ax0.plot(x_tip, tip_md, 'g', linewidth=0.5, linestyle='--')
ax0.fill_between(x_tip, tip0, tip_activation_hi, facecolor='r', alpha=0.7)
ax0.plot(x_tip, tip_hi, 'r', linewidth=0.5, linestyle='--')
ax0.set_title('Output membership activity')

# Turn off top/right axes
for ax in (ax0,):
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.get_xaxis().tick_bottom()
    ax.get_yaxis().tick_left()

plt.tight_layout()

"""# Fuzzy Control Systems: Advanced Example

https://pythonhosted.org/scikit-fuzzy/auto_examples/plot_control_system_advanced.html#example-plot-control-system-advanced-py
"""

import numpy as np
import skfuzzy.control as ctrl

# Sparse universe makes calculations faster, without sacrifice accuracy.
# Only the critical points are included here; making it higher resolution is
# unnecessary.
universe = np.linspace(-2, 2, 5)

# Create the three fuzzy variables - two inputs, one output
error = ctrl.Antecedent(universe, 'error')
delta = ctrl.Antecedent(universe, 'delta')
output = ctrl.Consequent(universe, 'output')

# Here we use the convenience `automf` to populate the fuzzy variables with
# terms. The optional kwarg `names=` lets us specify the names of our Terms.
names = ['nb', 'ns', 'ze', 'ps', 'pb']
error.automf(names=names)
delta.automf(names=names)
output.automf(names=names)

rule0 = ctrl.Rule(antecedent=((error['nb'] & delta['nb']) |
                              (error['ns'] & delta['nb']) |
                              (error['nb'] & delta['ns'])),
                  consequent=output['nb'], label='rule nb')

rule1 = ctrl.Rule(antecedent=((error['nb'] & delta['ze']) |
                              (error['nb'] & delta['ps']) |
                              (error['ns'] & delta['ns']) |
                              (error['ns'] & delta['ze']) |
                              (error['ze'] & delta['ns']) |
                              (error['ze'] & delta['nb']) |
                              (error['ps'] & delta['nb'])),
                  consequent=output['ns'], label='rule ns')

rule2 = ctrl.Rule(antecedent=((error['nb'] & delta['pb']) |
                              (error['ns'] & delta['ps']) |
                              (error['ze'] & delta['ze']) |
                              (error['ps'] & delta['ns']) |
                              (error['pb'] & delta['nb'])),
                  consequent=output['ze'], label='rule ze')

rule3 = ctrl.Rule(antecedent=((error['ns'] & delta['pb']) |
                              (error['ze'] & delta['pb']) |
                              (error['ze'] & delta['ps']) |
                              (error['ps'] & delta['ps']) |
                              (error['ps'] & delta['ze']) |
                              (error['pb'] & delta['ze']) |
                              (error['pb'] & delta['ns'])),
                  consequent=output['ps'], label='rule ps')

rule4 = ctrl.Rule(antecedent=((error['ps'] & delta['pb']) |
                              (error['pb'] & delta['pb']) |
                              (error['pb'] & delta['ps'])),
                  consequent=output['pb'], label='rule pb')

system = ctrl.ControlSystem(rules=[rule0, rule1, rule2, rule3, rule4])

# Later we intend to run this system with a 21*21 set of inputs, so we allow
# that many plus one unique runs before results are flushed.
# Subsequent runs would return in 1/8 the time!
sim = ctrl.ControlSystemSimulation(system, flush_after_run=21 * 21 + 1)

# We can simulate at higher resolution with full accuracy
upsampled = np.linspace(-2, 2, 21)
x, y = np.meshgrid(upsampled, upsampled)
z = np.zeros_like(x)

# Loop through the system 21*21 times to collect the control surface
for i in range(21):
    for j in range(21):
        sim.input['error'] = x[i, j]
        sim.input['delta'] = y[i, j]
        sim.compute()
        z[i, j] = sim.output['output']

# Plot the result in pretty 3D with alpha blending
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # Required for 3D plotting

fig = plt.figure(figsize=(8, 8))
ax = fig.add_subplot(111, projection='3d')

surf = ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='viridis',
                       linewidth=0.4, antialiased=True)

cset = ax.contourf(x, y, z, zdir='z', offset=-2.5, cmap='viridis', alpha=0.5)
cset = ax.contourf(x, y, z, zdir='x', offset=3, cmap='viridis', alpha=0.5)
cset = ax.contourf(x, y, z, zdir='y', offset=3, cmap='viridis', alpha=0.5)

ax.view_init(30, 200)

"""# Defuzzification

https://pythonhosted.org/scikit-fuzzy/auto_examples/plot_defuzzify.html#example-plot-defuzzify-py

"""

import numpy as np
import matplotlib.pyplot as plt
import skfuzzy as fuzz


# Generate trapezoidal membership function on range [0, 1]
x = np.arange(0, 5.05, 0.1)
mfx = fuzz.trapmf(x, [2, 2.5, 3, 4.5])

# Defuzzify this membership function five ways
defuzz_centroid = fuzz.defuzz(x, mfx, 'centroid')  # Same as skfuzzy.centroid
defuzz_bisector = fuzz.defuzz(x, mfx, 'bisector')
defuzz_mom = fuzz.defuzz(x, mfx, 'mom')
defuzz_som = fuzz.defuzz(x, mfx, 'som')
defuzz_lom = fuzz.defuzz(x, mfx, 'lom')

# Collect info for vertical lines
labels = ['centroid', 'bisector', 'mean of maximum', 'min of maximum',
          'max of maximum']
xvals = [defuzz_centroid,
         defuzz_bisector,
         defuzz_mom,
         defuzz_som,
         defuzz_lom]
colors = ['r', 'b', 'g', 'c', 'm']
ymax = [fuzz.interp_membership(x, mfx, i) for i in xvals]

# Display and compare defuzzification results against membership function
plt.figure(figsize=(8, 5))

plt.plot(x, mfx, 'k')
for xv, y, label, color in zip(xvals, ymax, labels, colors):
    plt.vlines(xv, 0, y, label=label, color=color)
plt.ylabel('Fuzzy membership')
plt.xlabel('Universe variable (arb)')
plt.ylim(-0.1, 1.1)
plt.legend(loc=2)

plt.show()

"""# ðŸ¤‘ Fuzzy Control Systems: The Tipping Problem

https://pythonhosted.org/scikit-fuzzy/auto_examples/plot_tipping_problem_newapi.html#example-plot-tipping-problem-newapi-py
"""

import numpy as np
import skfuzzy as fuzz
from skfuzzy import control as ctrl

# New Antecedent/Consequent objects hold universe variables and membership
# functions
quality = ctrl.Antecedent(np.arange(0, 11, 1), 'quality')
service = ctrl.Antecedent(np.arange(0, 11, 1), 'service')
tip = ctrl.Consequent(np.arange(0, 26, 1), 'tip')

# Auto-membership function population is possible with .automf(3, 5, or 7)
quality.automf(3)
service.automf(3)

# Custom membership functions can be built interactively with a familiar,
# Pythonic API
tip['low'] = fuzz.trimf(tip.universe, [0, 0, 13])
tip['medium'] = fuzz.trimf(tip.universe, [0, 13, 25])
tip['high'] = fuzz.trimf(tip.universe, [13, 25, 25])

# You can see how these look with .view()
quality['average'].view()

service.view()

tip.view()

rule1 = ctrl.Rule(quality['poor'] | service['poor'], tip['low'])
rule2 = ctrl.Rule(service['average'], tip['medium'])
rule3 = ctrl.Rule(service['good'] | quality['good'], tip['high'])

# rule1.view_n()  # ERROR

tipping_ctrl = ctrl.ControlSystem([rule1, rule2, rule3])

tipping = ctrl.ControlSystemSimulation(tipping_ctrl)

# Pass inputs to the ControlSystem using Antecedent labels with Pythonic API
# Note: if you like passing many inputs all at once, use .inputs(dict_of_data)
tipping.input['quality'] = 6.5
tipping.input['service'] = 9.8

# Crunch the numbers
tipping.compute()

print( tipping.output['tip'])
tip.view(sim=tipping)